首先说明一下几个概念：
## 阻塞与非阻塞
### 阻塞
阻塞状态指程序未得到所需计算资源时被挂起的状态。程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。

常见的阻塞形式有：网络 I/O 阻塞、磁盘 I/O 阻塞、用户输入阻塞等。阻塞是无处不在的，包括 CPU 切换上下文时，所有的进程都无法真正干事情，它们也会被阻塞。如果是多核 CPU 则正在执行上下文切换操作的核不可被利用。

### 2.2 非阻塞
程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的。

非阻塞并不是在任何程序级别、任何情况下都可以存在的。  
仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。

非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。

## 同步与异步
### 同步
不同程序单元为了完成某个任务，在执行过程中需靠某种通信方式以协调一致，称这些程序单元是同步执行的。

例如购物系统中更新商品库存，需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的。

简言之，同步意味着**有序**。

### 异步

为完成某个任务，不同程序单元之间过程中无需通信协调，也能完成任务的方式，不相关的程序单元之间可以是异步的。

例如，爬虫下载网页。调度程序调用下载程序后，即可调度其他任务，而无需与该下载任务保持通信以协调行为。不同网页的下载、保存等操作都是无关的，也无需相互通知协调。这些异步操作的完成时刻并不确定。

简言之，异步意味着**无序**。
## 进程、线程、协程 
### 进程
程序运行的一个实例，即程序运行的时候系统环境变量和用到的资源以及本身代码的集合。特点是一个CPU核心同一时间内只能运行一个进程。这对于并发来说是一个障碍，所以引入了更轻量的线程。
进程是程序在计算机上的一次执行活动，即正在运行中的应用程序，通常称为进程。当你运行一个程序，你就启动了一个进程。每个进程都有自己独立的地址空间(内存空间)，每当用户启动一个进程时，操作系统就会为该进程分配一个独立的内存空间，让应用程序在这个独立的内存空间中运行。
#### 多进程/多任务
在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程，也称多任务。现代的操作系统几乎都是多任务操作系统，能够同时管理多个进程的运行。
多进程的数据是分开的、共享复杂，需要用IPC；但同步简单。

### 线程
线程是操作系统能够进行运算的最小单位。线程可以并发执行并共享进程中的资源（数据）。其中，并发使用了时间切片，即为每一个线程分配cpu时间，执行超过分配的时间，就强制执行下一个等待的线程。这部分是系统进行调度的，用户不需要介入。
进程的使用场景有：需要频繁创建和销毁的优先用线程，如web服务器；需要进行大量计算的优先使用线程，如图像处理。
#### 多线程/并发
并发是指一段时间内（程序开始运行到结束的这段时间）执行多个程序（线程算是一个进程的子程序）。
多线程共享进程数据，共享简单；但同步复杂。

### 协程

线程解决了进程阻塞和并发的问题，类似的，协程解决了线程阻塞和并发的问题。

不同的是，线程是为了操作系统“同时”运行更多的程序。协程是为了让一个线程内的程序并发服务更多内容。

将线程中的代码继续细分为多个任务，然后像时间片轮转一样不断去执行这些任务。不同的是，线程切换是由操作系统的时间片控制的，而协程是程序自己实现的。  
协程的切换不是按照时间来算的，而是按照代码既定分配，就是说代码运行到这一行才启动协程，协程是可以由我们程序员自己操控的。

![](//upload-images.jianshu.io/upload_images/2929041-6b0fc081dfa177a2.png?imageMogr2/auto-orient/strip|imageView2/2/w/980/format/webp)

示意图

其与线程的区别有：

-   线程可以有多个协程，但同一时间内只能运行一个协程。
-   线程是系统调度，协程是应用自己调度。
## 小结
进程>线程>协程
一个系统下可运行多个进程，多进程由操作系统进行管理。
一个进程可包含多个线程，线程之间可以并行，线程的切换由进程调度。
一个线程又可包含多个协程，协程之间互斥，一个时刻只能工作一个协程，协程的切换由线程内程序自身控制。

js 主线程中运行协程的过程如下：

第一步，协程A开始执行。

第二步，协程A执行到一半，进入暂停，执行权转移到协程B。

第三步，（一段时间后）协程B交还执行权。

第四步，协程A恢复执行。

协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

### 生成器 generator

js 中的生成器利用的就是协程，利用协程，可以实现函数暂停执行和函数恢复执行。

执行生成器的过程如下：

```jsx
function* getResult() {
    let id_res = yield fetch(id_url);
    console.log(id_res)
    let id_text = yield id_res.text();
    console.log(id_text)


    let new_name_url = name_url + "?id=" + id_text
    console.log(new_name_url)


    let name_res = yield fetch(new_name_url)
    console.log(name_res)
    let name_text = yield name_res.text()
    console.log(name_text)
}


let result = getResult()
result.next().value.then((response) => {
    return result.next(response).value
}).then((response) => {
    return result.next(response).value
}).then((response) => {
    return result.next(response).value
}).then((response) => {
    return result.next(response).value
```

可见手动执行生成器很麻烦，需要写很多重复的代码。于是有人把执行的这部分代码抽象为co.js，使用co.js只需下面这行代码：

```jsx
co(getResult()).then(res => {})
```

但是也引入了外部的代码，为了解决这个问题，ES7 引入了 async/await。

### async/await

它改进了生成器的缺点，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。其实 async/await 技术背后的秘密就是 Promise 和生成器应用，往底层说，就是微任务和协程应用。
